---
title: "<div style='text-align:center ;font-size:40px;'><u>**Interactive Trial Data Analysis**</u></span>"
author: "<div style= 'text-align:center ; font-size:34px;'>Arnab Aich</span>"
date: "<div style= 'text-align:center ;font-size:24px;'> </span>"
format: 
  html:
    embed-resources: true
    theme: cerulean
    toc: true
    toc-title: "Table of Contents"
    code-fold: true
    self_contained: true
output:
  html_document:
    self_contained: true
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: fill
    storyboard: true
    social: menu
    source_code: embed
    storyboard_options:
      size: medium
      theme: dark
      scroll: true
header-includes:
  - |
    <style>
    h3 {
      font-size: 20px;
    }
    </style>
navbar:
  left:
    - text: "Imputation App"
      href: "#imputation-app"
    - text: "Summary Plots App"
      href: "#summary-plots-app"
    - text: "AUC Calculation App"
      href: "#auc-calculation-app"
    - text: "Index Calculation App"
      href: "#index-calculation-app"
editor: source
runtime: shiny
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(shiny)
library(plotly)
library(dplyr)
library(mice)
library(shinyjs)
library(gt)
library(shinyWidgets) 
library(shinycssloaders)
library(tidyverse)

```
Missing value analysis is crucial in ensuring the accuracy and validity of data analyses, especially in panel data which involves observations over time for the same subjects or entities. This type of data is particularly prone to missing entries due to various factors like attrition or non-response, which can introduce bias and affect the conclusions if not properly managed.

### Challenges in Panel Data

Panel data's unique challenges stem from:

- **Time Dependence**: Missing values may depend on the time sequence or previous values, complicating their imputation.
- **Inter-Subject Variability**: Variability across subjects can lead to distinct patterns of missingness, requiring nuanced imputation strategies.

### `mice` in Panel Data Context

The `mice` package in R, standing for Multivariate Imputation by Chained Equations, offers a sophisticated solution for handling missing data in panel datasets. It performs multiple imputation, creating several plausible fill-ins for missing data points which are then analyzed to account for the uncertainty inherent in the process of guessing these values.

### Advantages for Panel Data

Using `mice` in panel data settings is advantageous as it:

- Handles complex missing data scenarios where missingness is dependent on time and other variables.
- Utilizes all available data to inform the imputation process, thereby enhancing the accuracy and reliability of the data analysis.

### Using the `mice` Package

Before implementing `mice`, ensure your data is appropriately formatted, with subjects and their observations over time clearly structured and missing values marked as `NA`.

### Installation and Setup

The `mice` package can be installed and loaded into an R environment using standard package management commands. It is essential to have the package ready before starting the imputation process.

# <u>**Data Imputation Application</u>:**

This Shiny app provides tools for data imputation and visualization for clinical trial data. Users can impute missing data for C-peptide and Glucose measurements, visualize the imputed and raw data, and explore summary statistics interactively.

### App Features

The app is divided into several key components:

1. **Data Imputation**: Users can input parameters for multiple imputation and view the progress and status of imputing C-peptide and Glucose data.
2. **Data Visualization**: Users can explore both raw and imputed data through interactive plots and summary tables.

### Running the App

The app is structured to work within an R environment. To run the app:

1. Ensure all required packages are installed and loaded (e.g., `shiny`, `shinyjs`, `plotly`, `dplyr`, `gt`, `mice`).
2. Place the app code in an R script or within an R Markdown document with runtime `shiny`.
3. Execute the app by running the R script or knitting the R Markdown document.

### Imputation Parameters

In the **Data Imputation** section, users can specify:

- **Number of Imputations (m)**: Set the number of multiple imputations to be generated (default is 5).
- **Imputation Method**: Choose from methods like Predictive Mean Matching (`pmm`), Mean Imputation (`mean`), Normal Imputation (`norm`), Bootstrapped Normal Imputation (`norm.boot`), and Logistic Regression (`logreg`).
- **Random Seed**: Set a random seed for reproducibility.


```{r}
# UI for Imputation App
ui <- fluidPage(

  fluidRow(
    column(12,
           div(class = "well",
               fluidRow(
                 column(4,
                        numericInput("mValue", "Number of Imputations (m):", value = 5, min = 1)
                 ),
                 column(4,
                        selectInput("method", "Imputation Method:",
                                    choices = c("pmm", "mean", "norm", "norm.boot", "logreg"),
                                    selected = "pmm")
                 ),
                 column(4,
                        numericInput("seedValue", "Random Seed:", value = 123)
                 )
               )
           )
    )
  ),
  fluidRow(
    column(12,
           div(class = "well",
               actionButton("runBtn", "Run", class = "btn-primary", style = "display: block; margin: 0 auto;")
           )
    )
  ),
  
  fluidRow(
    column(6,
           div(class = "well",
               h3("C-peptide Data Imputation"),
               uiOutput("cpepProgressContainer"),    # This is where the progress bar will go
               textOutput("cpepStatus")
           )
    ),
    column(6,
           div(class = "well",
               h3("Glucose Data Imputation"),
               uiOutput("glucProgressContainer"),    # This is where the progress bar will go
               textOutput("glucStatus")
           )
    )
  ),
  
  # JavaScript code to update the progress bar
  tags$script(HTML("
    Shiny.addCustomMessageHandler('updateProgressBar', function(message) {
      var elem = document.getElementById(message.id);
      elem.style.width = message.value + '%';
      elem.innerHTML = message.value + '%';
    });
  "))
)

# Server for Imputation App
server <- function(input, output, session) {
  # import dataset
  data_cpep <- read.csv("data/CPEP_Data_with_Missing_Values.csv")
  data_gluc <- read.csv("data/Glucose_Data_with_Missing_Values.csv")

  observeEvent(input$runBtn, {

    # Show progress bars
    output$cpepProgressContainer <- renderUI({
      tags$div(class = "progress-bar-container",
               tags$div(id = "cpepProgressBar", class = "progress-bar", "0%")
      )
    })
    
    output$glucProgressContainer <- renderUI({
      tags$div(class = "progress-bar-container",
               tags$div(id = "glucProgressBar", class = "progress-bar", "0%")
      )
    })

    # Perform C-peptide data imputation with progress simulation
    for (i in 1:10) {
      Sys.sleep(0.5)  # Simulating computation
      progress_value <- i * 10
      session$sendCustomMessage(type = 'updateProgressBar', message = list(id = 'cpepProgressBar', value = progress_value))
    }
    
    data_cpep_mice <- complete(mice(data_cpep, m = input$mValue, method = input$method, seed = input$seedValue))
    assign("data_cpep_imputed", data_cpep_mice, envir = .GlobalEnv)
    
    # Save C-peptide imputed data to file
    write.csv(data_cpep_imputed, file = paste0("data/data_cpep_imputed.csv"), row.names = FALSE)
    
    output$cpepStatus <- renderText({
      "C-peptide data has been saved."
    })
    
    # Perform Glucose data imputation with progress simulation
    for (i in 1:10) {
      Sys.sleep(0.5)  # Simulating computation
      progress_value <- i * 10
      session$sendCustomMessage(type = 'updateProgressBar', message = list(id = 'glucProgressBar', value = progress_value))
    }
    
    data_gluc_mice <- complete(mice(data_gluc, m = input$mValue, method = input$method, seed = input$seedValue))
    assign("data_gluc_imputed", data_gluc_mice, envir = .GlobalEnv)
    
    # Save Glucose imputed data to file
    write.csv(data_gluc_imputed, file = paste0("data/data_gluc_imputed.csv"), row.names = FALSE)
    
    output$glucStatus <- renderText({
      "Glucose data has been saved."
    })
  })
}

shinyApp(ui = ui, server = server)
```


# <u>**Summary Application</u>:**
This Shiny app provides tools for visualizing summary statistics for clinical trial data, including glucose and C-peptide measurements. Users can explore summary plots for raw and imputed data, customize the visualization, and interact with the data to gain insights.

### Customizing the Visualization

The **Data Visualization** section allows customization of how the data is presented:

- **Measurement**: Select between `Glucose` and `C-peptide` data.
- **Visualization Type**: Choose between `Pooled` data (aggregated across all subjects) or `Individual` data (for a specific subject).
- **Interaction Plot Variable**: Select whether to plot data against `Visit` (time points) or `Time` (in minutes).
- **Plot Interaction**: Users can interact with the plots to explore different variables and statistical summaries.

### Additional Settings

- **Summary**: When `Pooled` is selected, users can add a summary statistic (e.g., mean, median) to the plots.
- **Confidence Interval**: Users can display confidence intervals around the summary statistic.
- **Summary Type**: Choose the type of summary statistic to display (e.g., mean, sd, median).
- **Confidence Level**: Adjust the confidence level for intervals (default is 95%).

### Example Usage

Here's how a typical workflow might look:

1. **Set Imputation Parameters**: Adjust the number of imputations, method, and random seed.
2. **Run Imputation**: Click the "Run Imputation" button to start the process. 
3. **Visualize Data**: Explore the raw and imputed data using the interactive plots. Switch between pooled and individual data, adjust summary settings, and view confidence intervals.

```{r }

# UI for the App
ui <- fluidPage(
  useShinyjs(),  # Enable shinyjs for showing/hiding UI elements
  # Main UI Elements
  fluidRow(
    column(4,
           div(class = "well",
               h3("Options"),
               radioButtons("Measurement", "Measurement:", choices = c("Glucose", "C-peptide"), selected = "C-peptide", inline = TRUE),
               radioButtons("Treatment", "Visualization:", choices = c("Pooled", "Individual"), selected = "Pooled", inline = TRUE),
                 radioButtons("plotvariable", "Interaction Plot Variable:", choices = c("Visit", "Time"), selected = "Visit", inline = TRUE)
               
           )
    ),
    column(4,
           div(class = "well",
               h3("Additional Settings"),
               conditionalPanel(condition = "input.Treatment == 'Pooled'",
               checkboxInput("Summary", "Summary", value = FALSE)
               ),
                conditionalPanel(condition = "input.Treatment == 'Pooled'",
               checkboxInput("CI", "Confidence Interval", value = FALSE)
                )
           )
    ),
    column(4,
           div(class = "well",
               h3("Summary Options"),
               conditionalPanel(
                 condition = "input.Summary == true ",
                 selectInput("SummaryType", "Summary:", choices = c("mean", "sd", "median", "min", "max", "IQR"), selected = "mean")
               ),
               conditionalPanel(
                 condition = "input.CI == true",
                 sliderInput("CI_level", "Confidence Level", min = 0.8, max = 1, value = 0.95, step = 0.025)
               ),
               conditionalPanel(
                 condition = "input.Treatment == 'Individual'",
                 uiOutput("individualSelect")
           )
    )
  ),

  # Run Button
  fluidRow(
    column(12,
           div(class = "well",
               actionButton("runBtn", "Run", class = "btn-primary", style = "display: block; margin: 0 auto;")
           )
    )
  ),

  # Plots and Tables
  fluidRow(
    column(6,
           div(class = "well",
               h3("Raw Data"),
               plotlyOutput("InteractionPlot_raw", height = "400px"),
               uiOutput("Summary_raw")
           )
    ),
    column(6,
           div(class = "well",
               h3("Imputed Data"),
               plotlyOutput("InteractionPlot_imputed", height = "400px"),
               uiOutput("Summary_imputed")
           )
    )
  )
))



# Server for the App
server <- function(input, output, session) {
  
  imputed_data <- reactive({
    list(cpep = data_cpep_imputed, gluc = data_gluc_imputed)
  })

  data <- reactive({
    if (input$Measurement == "Glucose") {
      list(raw = data_gluc, imputed = imputed_data()$gluc)
    } else {
      list(raw = data_cpep, imputed = imputed_data()$cpep)
    }
  })
   # Hide Summary checkbox if Individual is selected
  observe({
    if (input$Treatment == "Individual") {
      updateCheckboxInput(session, "Summary", value = FALSE)
      shinyjs::hide("Summary")
      shinyjs::hide("CI")
      shinyjs::hide("SummaryType")
      shinyjs::hide("CI_level")
      shinyjs::show("individualSelect")
    } else {
      shinyjs::show("Summary")
      shinyjs::show("CI")
      shinyjs::show("SummaryType")
      shinyjs::show("CI_level")
      shinyjs::hide("individualSelect")
    }
  })
 # UI for selecting individual IDs
  output$individualSelect <- renderUI({
      selectInput("selectedID", "Select ID:",
                  choices = unique(data()$raw$subject),
                  selected = unique(data()$raw$subject)[1])
  })
  observeEvent(input$runBtn, {
    # Show plots and tables after "Run" button is clicked
    show("InteractionPlot_raw")
    show("Summary_raw")
    show("InteractionPlot_imputed")
    show("Summary_imputed")

    # Interaction Plot for Raw Data
    output$InteractionPlot_raw <- renderPlotly({
      plot_data <- data()$raw
 

      if (input$Treatment == "Pooled") {
        summary_data <- plot_data %>%
          group_by(visit, time) %>%
          summarise(
            Measurement_mean = round(match.fun(input$SummaryType)(result, na.rm = TRUE), 3),
            Measurement_sd = sd(result, na.rm = TRUE),
            Measurement_lower = Measurement_mean - qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * Measurement_sd / sqrt(n()),
            Measurement_upper = Measurement_mean + qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * Measurement_sd / sqrt(n())
          ) %>%
          ungroup()

        plot <- switch(input$plotvariable,
                       "Visit" = {
                         plot_ly(summary_data, x = ~visit, y = ~Measurement_mean, color = ~time, type = 'scatter', mode = 'lines+markers') %>%
                           layout(
                             xaxis = list(title = "Visit"),
                             yaxis = list(title = paste(input$Measurement)),
                             legend = list(orientation = 'h', x = 0.5, xanchor = 'center', y = -0.2),
                             title = paste("Summary:", input$SummaryType)
                           )
                       },
                       "Time" = {
                         plot_ly(summary_data, x = ~time, y = ~Measurement_mean, color = ~visit, type = 'scatter', mode = 'lines+markers') %>%
                           layout(
                             xaxis = list(title = "Time"),
                             yaxis = list(title = paste(input$Measurement)),
                             legend = list(orientation = 'h', x = 0.5, xanchor = 'center', y = -0.2),
                             title = paste("Summary:", input$SummaryType)
                           )
                       })

        if (input$CI) {
          plot <- plot %>%
            add_ribbons(
              ymin = ~Measurement_lower, ymax = ~Measurement_upper,
              line = list(color = 'transparent'),
              fillcolor = ~paste0("rgba(", col2rgb("red")[1], ",", col2rgb("red")[2], ",", col2rgb("red")[3], ",0.2)"),
              hoverinfo = "none",
              showlegend = FALSE
            )
        }

      } else if (input$Treatment == "Individual") {
        plot_data <- plot_data %>% filter(subject == input$selectedID)

        plot <- switch(input$plotvariable,
                       "Visit" = {
                         plot_ly(plot_data, x = ~visit, y = ~result, color = ~time, type = 'scatter', mode = 'lines+markers') %>%
                           layout(
                             xaxis = list(title = "Visit"),
                             yaxis = list(title = paste(input$Measurement)),
                             legend = list(orientation = 'h', x = 0.5, xanchor = 'center', y = -0.2),
                             title = paste("Subject ID:", input$selectedID)
                           )
                       },
                       "Time" = {
                         plot_ly(plot_data, x = ~time, y = ~result, color = ~visit, type = 'scatter', mode = 'lines+markers') %>%
                           layout(
                             xaxis = list(title = "Time"),
                             yaxis = list(title = paste(input$Measurement)),
                             legend = list(orientation = 'h', x = 0.5, xanchor = 'center', y = -0.2),
                             title = paste("Subject ID:", input$selectedID)
                           )
                       })
      }

      plot
    })

    # Interaction Plot for Imputed Data
    output$InteractionPlot_imputed <- renderPlotly({
      plot_data <- data()$imputed
      if (input$Treatment == "Pooled") {
        summary_data <- plot_data %>%
          group_by(visit, time) %>%
          summarise(
            Measurement_mean = round(match.fun(input$SummaryType)(result, na.rm = TRUE), 3),
            Measurement_sd = sd(result, na.rm = TRUE),
            Measurement_lower = Measurement_mean - qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * Measurement_sd / sqrt(n()),
            Measurement_upper = Measurement_mean + qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * Measurement_sd / sqrt(n())
          ) %>%
          ungroup()

        plot <- switch(input$plotvariable,
                       "Visit" = {
                         plot_ly(summary_data, x = ~visit, y = ~Measurement_mean, color = ~time, type = 'scatter', mode = 'lines+markers') %>%
                           layout(
                             xaxis = list(title = "Visit"),
                             yaxis = list(title = paste(input$Measurement)),
                             legend = list(orientation = 'h', x = 0.5, xanchor = 'center', y = -0.2),
                             title = paste("Summary:", input$SummaryType)
                           )
                       },
                       "Time" = {
                         plot_ly(summary_data, x = ~time, y = ~Measurement_mean, color = ~visit, type = 'scatter', mode = 'lines+markers') %>%
                           layout(
                             xaxis = list(title = "Time"),
                             yaxis = list(title = paste(input$Measurement)),
                             legend = list(orientation = 'h', x = 0.5, xanchor = 'center', y = -0.2),
                             title = paste("Summary:", input$SummaryType)
                           )
                       })

        if (input$CI) {
          plot <- plot %>%
            add_ribbons(
              ymin = ~Measurement_lower, ymax = ~Measurement_upper,
              line = list(color = 'transparent'),
              fillcolor = ~paste0("rgba(", col2rgb("red")[1], ",", col2rgb("red")[2], ",", col2rgb("red")[3], ",0.2)"),
              hoverinfo = "none",
              showlegend = FALSE
            )
        }

      } else if (input$Treatment == "Individual") {
        plot_data <- plot_data %>% filter(subject == input$selectedID)

        plot <- switch(input$plotvariable,
                       "Visit" = {
                         plot_ly(plot_data, x = ~visit, y = ~result, color = ~time, type = 'scatter', mode = 'lines+markers') %>%
                           layout(
                             xaxis = list(title = "Visit"),
                             yaxis = list(title = paste(input$Measurement)),
                             legend = list(orientation = 'h', x = 0.5, xanchor = 'center', y = -0.2),
                             title = paste("Subject ID:", input$selectedID)
                           )
                       },
                       "Time" = {
                         plot_ly(plot_data, x = ~time, y = ~result, color = ~visit, type = 'scatter', mode = 'lines+markers') %>%
                           layout(
                             xaxis = list(title = "Time"),
                             yaxis = list(title = paste(input$Measurement)),
                             legend = list(orientation = 'h', x = 0.5, xanchor = 'center', y = -0.2),
                             title = paste("Subject ID:", input$selectedID)
                           )
                       })
      }

      plot
    })

    # Summary statistics for Raw Data
 output$Summary_raw <- renderUI({
      summary_data <- if (input$Treatment == "Pooled") {
        data()$raw %>%
          group_by(visit, time) %>%
          summarise(result = round(match.fun(input$SummaryType)(result, na.rm = TRUE), 3)) %>%
          pivot_wider(names_from = visit, values_from = result)
      } else {
        data()$raw %>%
          filter(subject == input$selectedID) %>%
          group_by(visit, time) %>%
          summarise(result = round(result, 3)) %>%
          pivot_wider(names_from = visit, values_from = result)  # Dynamic orientation
      }

      title_text <- if (input$Treatment == "Pooled") {
        paste("Summary:", input$SummaryType)
      } else {
        paste("Subject ID:", input$selectedID)
      }

      gt_table <- gt(summary_data) %>%
        tab_header(title = title_text) %>%
        fmt_number(columns = everything(), decimals = 2) %>%
        cols_align(align = "center", columns = everything()) %>%
        tab_style(
          style = list(
            cell_fill(color = "lightgreen"),
            cell_text(weight = "bold", color = "black")
          ),
          locations = cells_column_labels(everything())
        ) %>%
        tab_options(table.width = pct(100))

      gt_output <- gt_table %>%
        as_raw_html()

      HTML(gt_output)
    })
  
    # Summary statistics for Imputed Data
    output$Summary_imputed <- renderUI({
      summary_data <- if (input$Treatment == "Pooled") {
        data()$imputed %>%
          group_by(visit, time) %>%
          summarise(result = round(match.fun(input$SummaryType)(result, na.rm = TRUE), 3)) %>%
          pivot_wider(names_from = visit, values_from = result)
      } else {
        data()$imputed %>%
          filter(subject == input$selectedID) %>%
          group_by(visit, time) %>%
          summarise(result = round(result, 3)) %>%
          pivot_wider(names_from = visit, values_from = result)  # Dynamic orientation
      }

      title_text <- if (input$Treatment == "Pooled") {
        paste("Summary:", input$SummaryType)
      } else {
        paste("Subject ID:", input$selectedID)
      }

      gt_table <- gt(summary_data) %>%
        tab_header(title = title_text) %>%
        fmt_number(columns = everything(), decimals = 2) %>%
        cols_align(align = "center", columns = everything()) %>%
        tab_style(
          style = list(
            cell_fill(color = "lightgreen"),
            cell_text(weight = "bold", color = "black")
          ),
          locations = cells_column_labels(everything())
        ) %>%
        tab_options(table.width = pct(100))

      gt_output <- gt_table %>%
        as_raw_html()

      HTML(gt_output)
    })
  })
}
# Run the application
shinyApp(ui = ui, server = server)

```

# <u>**AUC Application</u>:**

This Shiny app provides a platform for calculating the Area Under the Curve (AUC) for glucose and C-peptide measurements from clinical trial data. The app also allows for visualizing the calculated AUC, both for raw and imputed data.
When considering a variable \( Y \) measured at specific time points \( t_1, t_2, \ldots, t_n \) during each visit \( V_j \), the area under the curve (AUC) for an individual visit can be calculated using the trapezoidal rule. This calculation is formally expressed as follows:

$$
\text{AUC}_{V_j} = \sum_{i=1}^{n_j-1} \frac{(t_{i+1} - t_i) \times (Y_{i+1} + Y_i)}{2}
$$

In this equation, \( t_i \) represents the time points within a particular visit, and \( Y_i \) denotes the corresponding values of the variable at those time points. The summation across these intervals provides the AUC for the visit \( V_j \).

When the objective is to aggregate the AUCs across multiple visits, the total AUC is determined by summing the AUCs for each visit, which is mathematically represented by:

$$
\text{Total AUC} = \sum_{j=1}^{m} \text{AUC}_{V_j}
$$

Alternatively, if an average AUC across all visits is required, this can be calculated by dividing the total AUC by the number of visits \( m \), as shown below:

$$
\text{Average AUC} = \frac{1}{m} \sum_{j=1}^{m} \text{AUC}_{V_j}
$$

These formulas provide a structured approach to calculating and aggregating AUCs in studies that involve repeated measurements across multiple visits.


### App Features

The app consists of several interactive components:

1. **Data Selection**: Users can select the type of measurement (Glucose or C-peptide) and specify the visualization type (Pooled or Individual).
2. **AUC Calculation**: The app calculates the AUC using the trapezoidal rule for both raw and imputed data.
3. **Visualization and Summary**: The app offers customizable options to visualize the AUC results and display summary statistics.

### Running the App

To run the app:

1. Ensure all required packages are installed (e.g., `shiny`, `shinyjs`, `plotly`, `dplyr`, `gt`).
2. Place the app code in an R script or within an R Markdown document with runtime `shiny`.
3. Execute the app by running the R script or knitting the R Markdown document.

### Data Selection

In the **Options** section, users can choose between:

- **Measurement**: Select either `Glucose` or `C-peptide` data.
- **Visualization**: Choose between `Pooled` (aggregated data) or `Individual` (data for a specific subject).

### Additional Settings

In the **Additional Settings** section:

- **Summary**: When `Pooled` is selected, users can enable the summary checkbox to add summary statistics to the plots.
- **Confidence Interval**: Users can enable confidence intervals for the plotted summary statistics.

### Customizing the Summary

In the **Summary Options** section, users can:

- **Summary Type**: Choose the type of summary statistic to display (e.g., mean, sd, median, min, max, IQR).
- **Confidence Level**: Adjust the confidence level for intervals (default is 95%).
- **Select Individual ID**: When `Individual` is selected, users can choose the specific subject ID for visualization.

### Interactive Elements

- **Run Button**: After setting all parameters, click the "Run" button to calculate the AUC and display the plots and summaries.
- **Plots and Tables**: The app will show the AUC plots and summary tables for both raw and imputed data after the "Run" button is clicked.

### Example Usage

1. **Select Data and Visualization**: Choose `Glucose` or `C-peptide` and whether to view `Pooled` or `Individual` data.
2. **Adjust Settings**: Toggle the summary and confidence interval options as needed.
3. **Run AUC Calculation**: Click the "Run" button to perform the AUC calculation and display the results.
4. **Explore Results**: View and interact with the AUC plots and summary tables.

```{r}
ui <- fluidPage(
  useShinyjs(),  # Enable shinyjs for showing/hiding UI elements

  # Main UI Elements
  fluidRow(
    column(4,
           div(class = "well",
               h3("Options"),
               radioButtons("Measurement", "Measurement:", choices = c("Glucose", "C-peptide"), selected = "C-peptide", inline = TRUE),
               radioButtons("Treatment", "Visualization:", choices = c("Pooled", "Individual"), selected = "Pooled", inline = TRUE)
           )
    ),
    column(4,
           div(class = "well",
               h3("Additional Settings"),
               conditionalPanel(
                 condition = "input.Treatment == 'Pooled'",
                 checkboxInput("AUC_Summary", "Summary", value = FALSE)
               ),
               conditionalPanel(
                 condition = "input.Treatment == 'Pooled'",
                 checkboxInput("CI", "Confidence Interval", value = FALSE)
               )
           )
    ),
    column(4,
           div(class = "well",
               h3("Summary Options"),
               conditionalPanel(
                 condition = "input.AUC_Summary == true ",
                 selectInput("AUC_SummaryType", "Summary:", choices = c("mean", "sd", "median", "min", "max", "IQR"), selected = "mean")
               ),
               conditionalPanel(
                 condition = "input.CI == true",
                 sliderInput("CI_level", "Confidence Level", min = 0.8, max = 1, value = 0.95, step = 0.025)
               ),
               conditionalPanel(
                 condition = "input.Treatment == 'Individual'",
                 uiOutput("individualSelect")
               )
           )
    )
  ),

  # Run Button
  fluidRow(
    column(12,
           div(class = "well",
               actionButton("runBtn", "Run", class = "btn-primary", style = "display: block; margin: 0 auto;")
           )
    )
  ),

  # Plots and Tables
  fluidRow(
    column(6,
           div(class = "well",
               h3("Raw Data"),
               plotlyOutput("AUCPlot_raw", height = "400px"),
               uiOutput("AUC_raw")
           )
    ),
    column(6,
           div(class = "well",
               h3("Imputed Data"),
               plotlyOutput("AUCPlot_imputed", height = "400px"),
               uiOutput("AUC_imputed")
           )
    )
  )
)

server <- function(input, output, session) {
  imputed_data <- reactive({
    list(cpep = data_cpep_imputed, gluc = data_gluc_imputed)
  })
  

  data <- reactive({
    if (input$Measurement == "Glucose") {
      list(raw = data_gluc, imputed = imputed_data()$gluc)
    } else {
      list(raw = data_cpep, imputed = imputed_data()$cpep)
    }
  })
    # Hide Summary checkbox if Individual is selected
  observe({
    if (input$Treatment == "Individual") {
      shinyjs::hide("AUC_Summary")
      shinyjs::hide("CI")
      shinyjs::hide("AUC_SummaryType")
      shinyjs::hide("CI_level")
      shinyjs::show("individualSelect")
    } else {
      shinyjs::show("AUC_Summary")
      shinyjs::show("CI")
      shinyjs::show("AUC_SummaryType")
      shinyjs::show("CI_level") 
      shinyjs::hide("individualSelect")
    }
  })
  # UI for selecting individual IDs
  output$individualSelect <- renderUI({
    selectInput("selectedID", "Select ID:",
                choices = unique(data()$raw$subject),
                selected = unique(data()$raw$subject)[1])
  })
  observeEvent(input$runBtn, {
    # Show AUC results after "Run" button is clicked
    show("AUC_raw")
    show("AUC_imputed")
    show("AUCPlot_raw")
    show("AUCPlot_imputed")

     # AUC Plot for raw data (Left Column) using plotly with conditional CI
  output$AUCPlot_raw <- renderPlotly({
    req(input$runBtn)
    data <- data()$raw
    data$time <- sapply(data$time, convert_to_minutes)

    auc_trapezoidal <- data %>%
      group_by(subject, visit) %>%
      summarise(auc = trapezoidal_auc(as.numeric(time), result)) %>%
      ungroup()
    auc_trapezoidal$visit <- factor(auc_trapezoidal$visit, levels = c("0", "2", "4", "8", "12", "16", "20", "26"))

    if (input$Treatment == "Pooled") {
      summary_data <- auc_trapezoidal %>%
        group_by(visit) %>%
        summarise(
          auc_mean = match.fun(input$AUC_SummaryType)(auc, na.rm = TRUE),
          auc_sd = sd(auc, na.rm = TRUE),
          auc_lower = auc_mean - qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * auc_sd / sqrt(n()),
          auc_upper = auc_mean + qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * auc_sd / sqrt(n())
        )
      plot <- plot_ly(summary_data, x = ~visit, y = ~auc_mean, name = 'AUC Mean', type = 'scatter', mode = 'lines+markers') %>%
        layout(xaxis = list(title = "Visit"),
               yaxis = list(title = "AUC"),
               showlegend = FALSE,
               title = paste("AUC Summary:", input$AUC_SummaryType)
        )

      if (input$CI) {
        plot <- plot %>%
          add_ribbons(ymin = ~auc_lower, ymax = ~auc_upper, name = 'CI',
                      line = list(color = 'rgba(7, 164, 181, 0.05)'),
                      fillcolor = 'rgba(7, 164, 181, 0.2)')
      }

    } else if (input$Treatment == "Individual") {
      auc_ID <- auc_trapezoidal %>% filter(subject == input$selectedID)
      plot <- plot_ly(auc_ID, x = ~visit, y = ~auc, type = 'scatter', mode = 'lines+markers',
                      name = 'AUC') %>%
        layout(xaxis = list(title = "Visit"),
               yaxis = list(title = "AUC"),
               showlegend = FALSE,
               title = paste("AUC of Subject ID:", input$selectedID)
        )
    }
    plot
  })
  
  # AUC summary table for raw data
  output$AUC_raw <- renderUI({
    auc_trapezoidal <- data()$raw %>%
      group_by(subject, visit) %>%
      summarise(auc = trapezoidal_auc(as.numeric(time), result)) %>%
      ungroup()
    auc_trapezoidal$visit <- factor(auc_trapezoidal$visit, levels = c("0", "2", "4", "8", "12", "16", "20", "26"))

    if (input$Treatment == "Pooled") {
      summary_data <- auc_trapezoidal %>%
        group_by(visit) %>%
        summarise(
          auc_mean = match.fun(input$AUC_SummaryType)(auc, na.rm = TRUE),
          auc_sd = sd(auc, na.rm = TRUE),
          auc_lower = auc_mean - qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * auc_sd / sqrt(n()),
          auc_upper = auc_mean + qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * auc_sd / sqrt(n())
        )
      summary_data$visit <- factor(summary_data$visit, levels = c("0", "2", "4", "8", "12", "16", "20", "26"))
      gt_table <- gt(summary_data) %>%
        tab_header(title = paste("AUC Summary:", input$AUC_SummaryType)) %>%
        fmt_number(columns = everything(), decimals = 2) %>%
        cols_align(align = "center", columns = everything()) %>%
        tab_style(
          style = list(
            cell_fill(color = "lightgreen"),
            cell_text(weight = "bold", color = "black")
          ),
          locations = cells_column_labels(everything())
        ) %>%
        tab_options(table.width = pct(100))

    } else if (input$Treatment == "Individual") {
      auc_ID <- auc_trapezoidal %>% filter(subject == input$selectedID)
      gt_table <- gt(auc_ID) %>%
        tab_header(title = paste("AUC of Subject ID:", input$selectedID)) %>%
        fmt_number(columns = everything(), decimals = 2) %>%
        cols_align(align = "center", columns = everything()) %>%
        tab_style(
          style = list(
            cell_fill(color = "lightgreen"),
            cell_text(weight = "bold", color = "black")
          ),
          locations = cells_column_labels(everything())
        ) %>%
        tab_options(table.width = pct(100))
    } else {
      NULL
    }
      gt_output <- gt_table %>%
        as_raw_html()

      HTML(gt_output)
    
    
  })
  
  # AUC plot for Imputed data (Right Column) using plotly with conditional CI
  output$AUCPlot_imputed <- renderPlotly({
    req(input$runBtn)
    data <- data()$imputed
    data$time <- sapply(data$time, convert_to_minutes)

    auc_trapezoidal <- data %>%
      filter(!is.na(result)) %>%   # Ensure NA values are excluded
      group_by(subject, visit) %>%
      summarise(auc = trapezoidal_auc(as.numeric(time), result)) %>%
      ungroup()
    auc_trapezoidal$visit <- factor(auc_trapezoidal$visit, levels = c("0", "2", "4", "8", "12", "16", "20", "26"))
    if (input$Treatment == "Pooled") {
      summary_data <- auc_trapezoidal %>%
        group_by(visit) %>%
        summarise(
          auc_mean = match.fun(input$AUC_SummaryType)(auc, na.rm = TRUE),
          auc_sd = sd(auc, na.rm = TRUE),
          auc_lower = auc_mean - qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * auc_sd / sqrt(n()),
          auc_upper = auc_mean + qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * auc_sd / sqrt(n())
        )
      summary_data$visit <- factor(summary_data$visit, levels = c("0", "2", "4", "8", "12", "16", "20", "26"))
      plot <- plot_ly(summary_data, x = ~visit, y = ~auc_mean, name = 'AUC Mean', type = 'scatter', mode = 'lines+markers') %>%
        layout(xaxis = list(title = "Visit"),
               yaxis = list(title = "AUC"),
               showlegend = FALSE,
               title = paste("AUC Summary:", input$AUC_SummaryType)
        )

      if (input$CI) {
        plot <- plot %>%
          add_ribbons(ymin = ~auc_lower, ymax = ~auc_upper, name = 'CI',
                      line = list(color = 'rgba(7, 164, 181, 0.05)'),
                      fillcolor = 'rgba(7, 164, 181, 0.2)')
      }

    } else if (input$Treatment == "Individual") {
      auc_ID <- auc_trapezoidal %>% filter(subject == input$selectedID)
      plot <- plot_ly(auc_ID, x = ~visit, y = ~auc, type = 'scatter', mode = 'lines+markers',
                      name = 'AUC') %>%
        layout(xaxis = list(title = "Visit"),
               yaxis = list(title = "AUC"),
               showlegend = FALSE,
               title = paste("AUC of Subject ID:", input$selectedID)
        )
    }
    plot
  })
  
  # AUC summary table for imputed data
  output$AUC_imputed <- renderUI({
    auc_trapezoidal <- data()$imputed %>%
      filter(!is.na(result)) %>%   # Ensure NA values are excluded
      group_by(subject, visit) %>%
      summarise(auc = trapezoidal_auc(as.numeric(time), result)) %>%
      ungroup()
    auc_trapezoidal$visit <- factor(auc_trapezoidal$visit, levels = c("0", "2", "4", "8", "12", "16", "20", "26"))

    if (input$Treatment == "Pooled") {
      summary_data <- auc_trapezoidal %>%
        group_by(visit) %>%
        summarise(
          auc_mean = match.fun(input$AUC_SummaryType)(auc, na.rm = TRUE),
          auc_sd = sd(auc, na.rm = TRUE),
          auc_lower = auc_mean - qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * auc_sd / sqrt(n()),
          auc_upper = auc_mean + qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * auc_sd / sqrt(n())
        )
      summary_data$visit <- factor(summary_data$visit, levels = c("0", "2", "4", "8", "12", "16", "20", "26"))
      gt_table <- gt(summary_data) %>%
        tab_header(title = paste("AUC Summary:", input$AUC_SummaryType)) %>%
        fmt_number(columns = everything(), decimals = 2) %>%
        cols_align(align = "center", columns = everything()) %>%
        tab_style(
          style = list(
            cell_fill(color = "lightgreen"),
            cell_text(weight = "bold", color = "black")
          ),
          locations = cells_column_labels(everything())
        ) %>%
        tab_options(table.width = pct(100))
    } else if (input$Treatment == "Individual") {
      auc_ID <- auc_trapezoidal %>% filter(subject == input$selectedID)
      gt_table <- gt(auc_ID) %>%
        tab_header(title = paste("AUC of Subject ID:", input$selectedID)) %>%
        fmt_number(columns = everything(), decimals = 2) %>%
        cols_align(align = "center", columns = everything()) %>%
        tab_style(
          style = list(
            cell_fill(color = "lightgreen"),
            cell_text(weight = "bold", color = "black")
          ),
          locations = cells_column_labels(everything())
        ) %>%
        tab_options(table.width = pct(100))
    } else {
      NULL
    }
       gt_output <- gt_table %>%
        as_raw_html()

      HTML(gt_output)
  })
  })
}
 shinyApp(ui = ui, server = server)

```

# <u>**Index AUC Application</u>:**

This guide explains how to use the Shiny app for calculating and visualizing the Index for Glucose and C-peptide measurements. The cpeptide index AUC is calculated as
The C-peptide index based on AUC is calculated as:

$$
\text{C-peptide index (AUC)} = \frac{\text{AUC of C-peptide}}{\text{AUC of Glucose}}\times 100.
$$
The app provides two modes of visualization, summary statistics, and confidence intervals, allowing users to explore the raw and imputed data interactively.

### App Features

1. Visualization Mode

The app offers two modes of data visualization:

- **Pooled Mode**: Displays aggregate data for all subjects. This mode enables the calculation of summary statistics and confidence intervals.
- **Individual Mode**: Displays data for a selected individual subject, allowing the user to explore individual trends in the data.

2. Summary Statistics (Pooled Mode Only)

In Pooled Mode, you can enable the calculation of summary statistics using the following options:

- **Summary Checkbox**: When enabled, the app displays a summary of the data based on the selected summary type.
- **Summary Type**: Choose from options such as mean, standard deviation (sd), median, minimum (min), maximum (max), and interquartile range (IQR).

3. Confidence Interval (CI) (Pooled Mode Only)

- **CI Checkbox**: When enabled, the app displays the confidence interval for the index. 
- **Confidence Level**: You can adjust the confidence level (from 80% to 100%) using the provided slider.

 4. Individual Selection (Individual Mode Only)

In Individual Mode, the app allows you to select a specific subject using a dropdown menu. This feature enables you to visualize the index for individual subjects across different visits.

### Running the App

To run the app:

1. Click the "Run" button to display the selected visualizations and summary statistics.
2. The app will generate two plots: one for the raw data and one for the imputed data. You can toggle between different visualization modes (Pooled or Individual) and customize the output by enabling or disabling the Summary and Confidence Interval options.

The app will also generate a detailed summary table for both the raw and imputed data. These tables show the index values for each visit and provide an overview of the calculated statistics.

```{r}

ui <- fluidPage(
  useShinyjs(),  # Enable shinyjs for showing/hiding UI elements
  # Main UI Elements
  fluidRow(
    column(6,
           div(class = "well",
               h3("Visualization Summary & CI"),
               radioButtons("Treatment", "Visualization:", choices = c("Pooled", "Individual"), selected = "Pooled", inline = TRUE),
               conditionalPanel(condition = "input.Treatment == 'Pooled'",
                 checkboxInput("Summary", "Summary", value = FALSE),
                 checkboxInput("CI", "Confidence Interval", value = FALSE)
               ),
               conditionalPanel(
                 condition = "input.Treatment == 'Individual'",
                 uiOutput("individualSelect")
               )
           )
    ),
    column(6,
           div(class = "well",
               h3("Other Options"),
               conditionalPanel(
                 condition = "input.Summary == true & input.Treatment == 'Pooled'",
                 selectInput("SummaryType", "Summary Type:", choices = c("mean", "sd", "median", "min", "max", "IQR"), selected = "mean")
               ),
               conditionalPanel(
                 condition = "input.CI == true & input.Treatment == 'Pooled'",
                 sliderInput("CI_level", "Confidence Level:", min = 0.8, max = 1, value = 0.95, step = 0.025)
               )
           )
    )
  ),

  # Run Button
  fluidRow(
    column(12,
           div(class = "well",
               actionButton("runBtn", "Run", class = "btn-primary", style = "display: block; margin: 0 auto;")
           )
    )
  ),

  # Plots and Tables (Main Panel - Left as it is)
  fluidRow(
    column(6,
           div(class = "well",
               h3("Raw Data"),
               plotlyOutput("IndexPlot_raw", height = "400px"),
               uiOutput("IndexSummary_raw")
           )
    ),
    column(6,
           div(class = "well",
               h3("Imputed Data"),
               plotlyOutput("IndexPlot_imputed", height = "400px"),
               uiOutput("IndexSummary_imputed")
           )
    )
  )
)

server <- function(input, output, session){
  # import dataset
  data_cpep <- read.csv("data/CPEP_Data_with_Missing_Values.csv")
  data_gluc <- read.csv("data/Glucose_Data_with_Missing_Values.csv")
  imputed_data <- reactive({
    list(cpep = data_cpep_imputed, gluc = data_gluc_imputed)
  })
  data <- reactive({
    list(raw = list(cpep = data_cpep, gluc = data_gluc),
         imputed = list(cpep = imputed_data()$cpep, gluc = imputed_data()$gluc))
  })
  
  observe({
    if (input$Treatment == "Individual") {
      shinyjs::hide("Summary")
      shinyjs::hide("CI")
      shinyjs::hide("SummaryType")
      shinyjs::hide("CI_level")
      shinyjs::show("individualSelect")
    } else {
      shinyjs::show("Summary")
      shinyjs::show("CI")
      shinyjs::show("SummaryType")
      shinyjs::show("CI_level") 
      shinyjs::hide("individualSelect")
    }
  })
  
  output$individualSelect <- renderUI({
    selectInput("selectedID", "Select ID:",
                choices = unique(data()$raw$cpep$subject),
                selected = unique(data()$raw$cpep$subject)[1])
  })
  
  observeEvent(input$runBtn, {
    shinyjs::show("IndexPlot_raw")
    shinyjs::show("IndexPlot_imputed")
    shinyjs::show("IndexSummary_raw")
    shinyjs::show("IndexSummary_imputed")
    
    # Interaction Plot for Raw Data Index using plotly
    output$IndexPlot_raw <- renderPlotly({
      req(input$runBtn)
      
      plot_data <- calculate_index(data()$raw$cpep, data()$raw$gluc)
      
      if (input$Treatment == "Pooled") {
        summary_data <- plot_data %>%
          group_by(visit) %>%
          summarise(
            index_mean = round(match.fun(input$SummaryType)(index, na.rm = TRUE), 3),
            index_sd = sd(index, na.rm = TRUE),
            index_lower = index_mean - qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * index_sd / sqrt(n()),
            index_upper = index_mean + qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * index_sd / sqrt(n())
          ) %>%
          ungroup()
        
        plot <- plot_ly(summary_data, x = ~visit, y = ~index_mean, type = 'scatter', mode = 'lines+markers') %>%
          layout(
            xaxis = list(title = "Visit"),
            yaxis = list(title = "Index"),
            title = paste("Index Summary:", input$SummaryType)
          )
        if (input$CI) {
          plot <- plot %>%
            add_ribbons(
              ymin = ~index_lower, ymax = ~index_upper,
              line = list(color = 'transparent'),
              fillcolor = ~paste0("rgba(", col2rgb("red")[1], ",", col2rgb("red")[2], ",", col2rgb("red")[3], ",0.2)"),
              hoverinfo = "none",
              showlegend = FALSE
            )
        }
      } else if (input$Treatment == "Individual") {
        plot_data <- plot_data %>% filter(subject == input$selectedID)
        
        plot <- plot_ly(plot_data %>% filter(!is.na(index)), x = ~visit, y = ~index, type = 'scatter', mode = 'lines+markers') %>%
          layout(
            xaxis = list(title = "Visit"),
            yaxis = list(title = "Index"),
            title = paste("Subject ID:", input$selectedID)
          )
      }
      plot
    })
    
    # Interaction Plot for Imputed Data Index using plotly
    output$IndexPlot_imputed <- renderPlotly({
      req(input$runBtn)
      
      plot_data <- calculate_index(data()$imputed$cpep, data()$imputed$gluc)
      
      if (input$Treatment == "Pooled") {
        summary_data <- plot_data %>%
          group_by(visit) %>%
          summarise(
            index_mean = round(match.fun(input$SummaryType)(index, na.rm = TRUE), 3),
            index_sd = sd(index, na.rm = TRUE),
            index_lower = index_mean - qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * index_sd / sqrt(n()),
            index_upper = index_mean + qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * index_sd / sqrt(n())
          ) %>%
          ungroup()
        
        plot <- plot_ly(summary_data, x = ~visit, y = ~index_mean, type = 'scatter', mode = 'lines+markers') %>%
          layout(
            xaxis = list(title = "Visit"),
            yaxis = list(title = "Index"),
            title = paste("Index Summary :", input$SummaryType)
          )
        
        if (input$CI) {
          plot <- plot %>%
            add_ribbons(
              ymin = ~index_lower, ymax = ~index_upper,
              line = list(color = 'transparent'),
              fillcolor = ~paste0("rgba(", col2rgb("red")[1], ",", col2rgb("red")[2], ",", col2rgb("red")[3], ",0.2)"),
              hoverinfo = "none",
              showlegend = FALSE
            )
        }
      } else if (input$Treatment == "Individual") {
        plot_data <- plot_data %>% filter(subject == input$selectedID)
        plot <- plot_ly(plot_data %>% filter(!is.na(index)), x = ~visit, y = ~index, type = 'scatter', mode = 'lines+markers') %>%
          layout(
            xaxis = list(title = "Visit"),
            yaxis = list(title = "Index"),
            title = paste("Subject ID:", input$selectedID)
          )
      }
      
      plot
    })
    
    # Summary for Raw Data Index using gt
    output$IndexSummary_raw <- renderUI({
      req(input$runBtn)
      
      index_data <- calculate_index(data()$raw$cpep, data()$raw$gluc)
      
      summary_data <- if (input$Treatment == "Pooled") {
        index_data %>%
          group_by(visit) %>%
          summarise(index_summary = round(match.fun(input$SummaryType)(index, na.rm = TRUE), 3)) %>%
          pivot_wider(names_from = visit, values_from = index_summary)
      } else {
        index_data %>%
          filter(subject == input$selectedID) %>%
          group_by(visit) %>%
          summarise(index_summary = round(index, 3)) %>%
          pivot_wider(names_from = visit, values_from = index_summary)
      }
      
      title_text <- if (input$Treatment == "Pooled") {
        paste("Index Summary:", input$SummaryType)
      } else {
        paste("Subject ID:", input$selectedID)
      }
      
      gt_table <- gt(summary_data) %>%
        tab_header(title = title_text) %>%
        fmt_number(columns = everything(), decimals = 2) %>%
        cols_align(align = "center", columns = everything()) %>%
        tab_style(
          style = list(
            cell_fill(color = "lightgreen"),
            cell_text(weight = "bold", color = "black")
          ),
          locations = cells_column_labels(everything())
        ) %>%
        tab_options(table.width = pct(100))
      
      gt_output <- gt_table %>%
        as_raw_html()
      
      HTML(gt_output)
    })
    
    # Summary for Imputed Data Index using gt
    output$IndexSummary_imputed <- renderUI({
      req(input$runBtn)
      
      index_data <- calculate_index(data()$imputed$cpep, data()$imputed$gluc)
      
      summary_data <- if (input$Treatment == "Pooled") {
        index_data %>%
          group_by(visit) %>%
          summarise(index_summary = round(match.fun(input$SummaryType)(index, na.rm = TRUE), 3)) %>%
          pivot_wider(names_from = visit, values_from = index_summary)
      } else {
        index_data %>%
          filter(subject == input$selectedID) %>%
          group_by(visit) %>%
          summarise(index_summary = round(index, 3)) %>%
          pivot_wider(names_from = visit, values_from = index_summary)
      }
      
      title_text <- if (input$Treatment == "Pooled") {
        paste("Index Summary :", input$SummaryType)
      } else {
        paste("Subject ID:", input$selectedID)
      }
      
      gt_table <- gt(summary_data) %>%
        tab_header(title = title_text) %>%
        fmt_number(columns = everything(), decimals = 2) %>%
        cols_align(align = "center", columns = everything()) %>%
        tab_style(
          style = list(
            cell_fill(color = "lightgreen"),
            cell_text(weight = "bold", color = "black")
          ),
          locations = cells_column_labels(everything())
        ) %>%
        tab_options(table.width = pct(100))
      
      gt_output <- gt_table %>%
        as_raw_html()
      
      HTML(gt_output)
    })
  })
}

shinyApp(ui = ui, server = server)


```

## <u>**Conclusion</u>:**

This document has systematically illustrated the application of advanced imputation techniques and dynamic visualizations to enhance the reliability and interpretation of trial data. Through the deployment of the `mice` package and Shiny apps, complexities of handling missing values in panel data are effectively addressed, ensuring a robust analytical foundation. As this exploration concludes, it's crucial to acknowledge that the ability to manipulate and visualize data dynamically not only enriches analysis but also extends the potential for insightful discoveries in clinical research. This serves as a stepping stone towards more data-driven decision-making in future studies.


