---
title: "Interactive Trial Data Analysis"
author: "Arnab Aich"
date: "`r Sys.Date()`"
format:
  html:
    embed-resources: true
    theme: cerulean
    toc: true
    toc-title: "Table of Contents"
    code-fold: true
    self_contained: true
output:
  html_document:
    self_contained: true
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: fill
    storyboard: true
    social: menu
    source_code: embed
    storyboard_options:
      size: medium
      theme: dark
      scroll: true
navbar:
  title: "Biomea Trial Data Analysis"
  left:
    - text: "Imputation App"
      href: "#imputation-app"
    - text: "Summary Plots App"
      href: "#summary-plots-app"
    - text: "AUC Calculation App"
      href: "#auc-calculation-app"
    - text: "Index Calculation App"
      href: "#index-calculation-app"
editor: source
runtime: shiny
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(shiny)
library(plotly)
library(dplyr)
library(mice)
library(shinyjs)
library(gt)
library(shinyWidgets) 
library(shinycssloaders)

```
## Introduction to Missing Value Analysis in Panel Data

Missing value analysis is crucial in ensuring the accuracy and validity of data analyses, especially in panel data which involves observations over time for the same subjects or entities. This type of data is particularly prone to missing entries due to various factors like attrition or non-response, which can introduce bias and affect the conclusions if not properly managed.

### Challenges in Panel Data

Panel data's unique challenges stem from:

- **Time Dependence**: Missing values may depend on the time sequence or previous values, complicating their imputation.
- **Inter-Subject Variability**: Variability across subjects can lead to distinct patterns of missingness, requiring nuanced imputation strategies.

## `mice` in Panel Data Context

The `mice` package in R, standing for Multivariate Imputation by Chained Equations, offers a sophisticated solution for handling missing data in panel datasets. It performs multiple imputation, creating several plausible fill-ins for missing data points which are then analyzed to account for the uncertainty inherent in the process of guessing these values.

### Advantages for Panel Data

Using `mice` in panel data settings is advantageous as it:

- Handles complex missing data scenarios where missingness is dependent on time and other variables.
- Utilizes all available data to inform the imputation process, thereby enhancing the accuracy and reliability of the data analysis.

## Using the `mice` Package

Before implementing `mice`, ensure your data is appropriately formatted, with subjects and their observations over time clearly structured and missing values marked as `NA`.

### Installation and Setup

The `mice` package can be installed and loaded into an R environment using standard package management commands. It is essential to have the package ready before starting the imputation process.

### Running the Imputation

1. **Define the Imputation Model**: Set up the imputation method for each variable in your dataset. `mice` can automatically select suitable methods or allow for manual specification based on detailed knowledge of the data.
2. **Execute Imputation**: Use the `mice()` function, specifying the number of imputations to generate. This function applies a series of predictive models, each conditioning on other variables, to iteratively fill in missing values across multiple cycles.
```{r}
# UI for Imputation App
ui <- fluidPage(
  tags$head(
    tags$link(rel = "stylesheet", type = "text/css", href = "styles.css")
  ),
  
  titlePanel("Data Imputation App"),
  
  fluidRow(
    column(12,
           div(class = "well",
               fluidRow(
                 column(4,
                        numericInput("mValue", "Number of Imputations (m):", value = 5, min = 1)
                 ),
                 column(4,
                        selectInput("method", "Imputation Method:",
                                    choices = c("pmm", "mean", "norm", "norm.boot", "logreg"),
                                    selected = "pmm")
                 ),
                 column(4,
                        numericInput("seedValue", "Random Seed:", value = 123)
                 )
               )
           )
    )
  ),
  
  fluidRow(
    column(12,
           div(class = "well",
               actionButton("runBtn", "Run Imputation", class = "btn-primary", style = "display: block; margin: 0 auto;")
           )
    )
  ),
  
  fluidRow(
    column(6,
           div(class = "well",
               h3("C-peptide Data Imputation"),
               uiOutput("cpepProgressContainer"),    # This is where the progress bar will go
               textOutput("cpepStatus")
           )
    ),
    column(6,
           div(class = "well",
               h3("Glucose Data Imputation"),
               uiOutput("glucProgressContainer"),    # This is where the progress bar will go
               textOutput("glucStatus")
           )
    )
  ),
  
  # JavaScript code to update the progress bar
  tags$script(HTML("
    Shiny.addCustomMessageHandler('updateProgressBar', function(message) {
      var elem = document.getElementById(message.id);
      elem.style.width = message.value + '%';
      elem.innerHTML = message.value + '%';
    });
  "))
)

# Server for Imputation App
server <- function(input, output, session) {

  observeEvent(input$runBtn, {

    # Show progress bars
    output$cpepProgressContainer <- renderUI({
      tags$div(class = "progress-bar-container",
               tags$div(id = "cpepProgressBar", class = "progress-bar", "0%")
      )
    })
    
    output$glucProgressContainer <- renderUI({
      tags$div(class = "progress-bar-container",
               tags$div(id = "glucProgressBar", class = "progress-bar", "0%")
      )
    })

    # Perform C-peptide data imputation with progress simulation
    for (i in 1:10) {
      Sys.sleep(0.5)  # Simulating computation
      progress_value <- i * 10
      session$sendCustomMessage(type = 'updateProgressBar', message = list(id = 'cpepProgressBar', value = progress_value))
    }
    
    data_cpep_mice <- complete(mice(data_cpep, m = input$mValue, method = input$method, seed = input$seedValue))
    assign("data_cpep_imputed", data_cpep_mice, envir = .GlobalEnv)
    
    # Save C-peptide imputed data to file
    write.csv(data_cpep_imputed, file = paste0("data/data_cpep_imputed.csv"), row.names = FALSE)
    
    output$cpepStatus <- renderText({
      "C-peptide data has been saved."
    })
    
    # Perform Glucose data imputation with progress simulation
    for (i in 1:10) {
      Sys.sleep(0.5)  # Simulating computation
      progress_value <- i * 10
      session$sendCustomMessage(type = 'updateProgressBar', message = list(id = 'glucProgressBar', value = progress_value))
    }
    
    data_gluc_mice <- complete(mice(data_gluc, m = input$mValue, method = input$method, seed = input$seedValue))
    assign("data_gluc_imputed", data_gluc_mice, envir = .GlobalEnv)
    
    # Save Glucose imputed data to file
    write.csv(data_gluc_imputed, file = paste0("data/data_gluc_imputed.csv"), row.names = FALSE)
    
    output$glucStatus <- renderText({
      "Glucose data has been saved."
    })
  })
}

shinyApp(ui = ui, server = server)
```

<<<<<<< HEAD
**import data sets into the environment**
=======
**import data sets intp the environment**
>>>>>>> 6c217b0e56589a7f901748bd8bc1c21d124b8ca5
```{r}
source("data_clean.R")
```


# Step 2: Generate Summary Plots

## Summary Plots App

```{r }

# UI for the App
ui <- fluidPage(
  useShinyjs(),  # Enable shinyjs for showing/hiding UI elements
 tags$head(
    tags$link(rel = "stylesheet", type = "text/css", href = "styles.css")
  ),

  # Main UI Elements
  fluidRow(
    column(4,
           div(class = "well",
               h3("Options"),
               radioButtons("Measurement", "Measurement:", choices = c("Glucose", "C-peptide"), selected = "C-peptide", inline = TRUE),
               radioButtons("Treatment", "Visualization:", choices = c("Pooled", "Individual"), selected = "Pooled", inline = TRUE),
                 radioButtons("plotvariable", "Interaction Plot Variable:", choices = c("Visit", "Time"), selected = "Visit", inline = TRUE)
               
           )
    ),
    column(4,
           div(class = "well",
               h3("Additional Settings"),
               conditionalPanel(condition = "input.Treatment == 'Pooled'",
               checkboxInput("Summary", "Summary", value = FALSE)
               ),
                conditionalPanel(condition = "input.Treatment == 'Pooled'",
               checkboxInput("CI", "Confidence Interval", value = FALSE)
                )
           )
    ),
    column(4,
           div(class = "well",
               h3("Summary Options"),
               conditionalPanel(
                 condition = "input.Summary == true ",
                 selectInput("SummaryType", "Summary:", choices = c("mean", "sd", "median", "min", "max", "IQR"), selected = "mean")
               ),
               conditionalPanel(
                 condition = "input.CI == true",
                 sliderInput("CI_level", "Confidence Level", min = 0.8, max = 1, value = 0.95, step = 0.025)
               ),
               conditionalPanel(
                 condition = "input.Treatment == 'Individual'",
                 uiOutput("individualSelect")
           )
    )
  ),

  # Run Button
  fluidRow(
    column(12,
           div(class = "well",
               actionButton("runBtn", "Run", class = "btn-primary", style = "display: block; margin: 0 auto;")
           )
    )
  ),

  # Plots and Tables
  fluidRow(
    column(6,
           div(class = "well",
               h3("Raw Data"),
               plotlyOutput("InteractionPlot_raw", height = "400px"),
               uiOutput("Summary_raw")
           )
    ),
    column(6,
           div(class = "well",
               h3("Imputed Data"),
               plotlyOutput("InteractionPlot_imputed", height = "400px"),
               uiOutput("Summary_imputed")
           )
    )
  )
))



# Server for the App
server <- function(input, output, session) {
  
  imputed_data <- reactive({
    list(cpep = data_cpep_imputed, gluc = data_gluc_imputed)
  })

  data <- reactive({
    if (input$Measurement == "Glucose") {
      list(raw = data_gluc, imputed = imputed_data()$gluc)
    } else {
      list(raw = data_cpep, imputed = imputed_data()$cpep)
    }
  })
   # Hide Summary checkbox if Individual is selected
  observe({
    if (input$Treatment == "Individual") {
      updateCheckboxInput(session, "Summary", value = FALSE)
      shinyjs::hide("Summary")
      shinyjs::hide("CI")
      shinyjs::hide("SummaryType")
      shinyjs::hide("CI_level")
      shinyjs::show("individualSelect")
    } else {
      shinyjs::show("Summary")
      shinyjs::show("CI")
      shinyjs::show("SummaryType")
      shinyjs::show("CI_level")
      shinyjs::hide("individualSelect")
    }
  })
 # UI for selecting individual IDs
  output$individualSelect <- renderUI({
      selectInput("selectedID", "Select ID:",
                  choices = unique(data()$raw$subject),
                  selected = unique(data()$raw$subject)[1])
  })
  observeEvent(input$runBtn, {
    # Show plots and tables after "Run" button is clicked
    show("InteractionPlot_raw")
    show("Summary_raw")
    show("InteractionPlot_imputed")
    show("Summary_imputed")

    # Interaction Plot for Raw Data
    output$InteractionPlot_raw <- renderPlotly({
      plot_data <- data()$raw
 

      if (input$Treatment == "Pooled") {
        summary_data <- plot_data %>%
          group_by(visit, time) %>%
          summarise(
            Measurement_mean = round(match.fun(input$SummaryType)(result, na.rm = TRUE), 3),
            Measurement_sd = sd(result, na.rm = TRUE),
            Measurement_lower = Measurement_mean - qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * Measurement_sd / sqrt(n()),
            Measurement_upper = Measurement_mean + qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * Measurement_sd / sqrt(n())
          ) %>%
          ungroup()

        plot <- switch(input$plotvariable,
                       "Visit" = {
                         plot_ly(summary_data, x = ~visit, y = ~Measurement_mean, color = ~time, type = 'scatter', mode = 'lines+markers') %>%
                           layout(
                             xaxis = list(title = "Visit"),
                             yaxis = list(title = paste(input$Measurement)),
                             legend = list(orientation = 'h', x = 0.5, xanchor = 'center', y = -0.2),
                             title = paste("Summary:", input$SummaryType)
                           )
                       },
                       "Time" = {
                         plot_ly(summary_data, x = ~time, y = ~Measurement_mean, color = ~visit, type = 'scatter', mode = 'lines+markers') %>%
                           layout(
                             xaxis = list(title = "Time"),
                             yaxis = list(title = paste(input$Measurement)),
                             legend = list(orientation = 'h', x = 0.5, xanchor = 'center', y = -0.2),
                             title = paste("Summary:", input$SummaryType)
                           )
                       })

        if (input$CI) {
          plot <- plot %>%
            add_ribbons(
              ymin = ~Measurement_lower, ymax = ~Measurement_upper,
              line = list(color = 'transparent'),
              fillcolor = ~paste0("rgba(", col2rgb("red")[1], ",", col2rgb("red")[2], ",", col2rgb("red")[3], ",0.2)"),
              hoverinfo = "none",
              showlegend = FALSE
            )
        }

      } else if (input$Treatment == "Individual") {
        plot_data <- plot_data %>% filter(subject == input$selectedID)

        plot <- switch(input$plotvariable,
                       "Visit" = {
                         plot_ly(plot_data, x = ~visit, y = ~result, color = ~time, type = 'scatter', mode = 'lines+markers') %>%
                           layout(
                             xaxis = list(title = "Visit"),
                             yaxis = list(title = paste(input$Measurement)),
                             legend = list(orientation = 'h', x = 0.5, xanchor = 'center', y = -0.2),
                             title = paste("Subject ID:", input$selectedID)
                           )
                       },
                       "Time" = {
                         plot_ly(plot_data, x = ~time, y = ~result, color = ~visit, type = 'scatter', mode = 'lines+markers') %>%
                           layout(
                             xaxis = list(title = "Time"),
                             yaxis = list(title = paste(input$Measurement)),
                             legend = list(orientation = 'h', x = 0.5, xanchor = 'center', y = -0.2),
                             title = paste("Subject ID:", input$selectedID)
                           )
                       })
      }

      plot
    })

    # Interaction Plot for Imputed Data
    output$InteractionPlot_imputed <- renderPlotly({
      plot_data <- data()$imputed
      if (input$Treatment == "Pooled") {
        summary_data <- plot_data %>%
          group_by(visit, time) %>%
          summarise(
            Measurement_mean = round(match.fun(input$SummaryType)(result, na.rm = TRUE), 3),
            Measurement_sd = sd(result, na.rm = TRUE),
            Measurement_lower = Measurement_mean - qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * Measurement_sd / sqrt(n()),
            Measurement_upper = Measurement_mean + qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * Measurement_sd / sqrt(n())
          ) %>%
          ungroup()

        plot <- switch(input$plotvariable,
                       "Visit" = {
                         plot_ly(summary_data, x = ~visit, y = ~Measurement_mean, color = ~time, type = 'scatter', mode = 'lines+markers') %>%
                           layout(
                             xaxis = list(title = "Visit"),
                             yaxis = list(title = paste(input$Measurement)),
                             legend = list(orientation = 'h', x = 0.5, xanchor = 'center', y = -0.2),
                             title = paste("Summary:", input$SummaryType)
                           )
                       },
                       "Time" = {
                         plot_ly(summary_data, x = ~time, y = ~Measurement_mean, color = ~visit, type = 'scatter', mode = 'lines+markers') %>%
                           layout(
                             xaxis = list(title = "Time"),
                             yaxis = list(title = paste(input$Measurement)),
                             legend = list(orientation = 'h', x = 0.5, xanchor = 'center', y = -0.2),
                             title = paste("Summary:", input$SummaryType)
                           )
                       })

        if (input$CI) {
          plot <- plot %>%
            add_ribbons(
              ymin = ~Measurement_lower, ymax = ~Measurement_upper,
              line = list(color = 'transparent'),
              fillcolor = ~paste0("rgba(", col2rgb("red")[1], ",", col2rgb("red")[2], ",", col2rgb("red")[3], ",0.2)"),
              hoverinfo = "none",
              showlegend = FALSE
            )
        }

      } else if (input$Treatment == "Individual") {
        plot_data <- plot_data %>% filter(subject == input$selectedID)

        plot <- switch(input$plotvariable,
                       "Visit" = {
                         plot_ly(plot_data, x = ~visit, y = ~result, color = ~time, type = 'scatter', mode = 'lines+markers') %>%
                           layout(
                             xaxis = list(title = "Visit"),
                             yaxis = list(title = paste(input$Measurement)),
                             legend = list(orientation = 'h', x = 0.5, xanchor = 'center', y = -0.2),
                             title = paste("Subject ID:", input$selectedID)
                           )
                       },
                       "Time" = {
                         plot_ly(plot_data, x = ~time, y = ~result, color = ~visit, type = 'scatter', mode = 'lines+markers') %>%
                           layout(
                             xaxis = list(title = "Time"),
                             yaxis = list(title = paste(input$Measurement)),
                             legend = list(orientation = 'h', x = 0.5, xanchor = 'center', y = -0.2),
                             title = paste("Subject ID:", input$selectedID)
                           )
                       })
      }

      plot
    })

    # Summary statistics for Raw Data
    output$Summary_raw <- renderUI({
      summary_data <- if (input$Treatment == "Pooled") {
        data()$raw %>%
          group_by(visit, time) %>%
          summarise(result = round(match.fun(input$SummaryType)(result, na.rm = TRUE), 3)) %>%
          pivot_wider(names_from = visit, values_from = result)
      } else {
        data()$raw %>%
          filter(subject == input$selectedID) %>%
          group_by(visit, time) %>%
          summarise(result = round(result, 3)) %>%
          pivot_wider(names_from = visit, values_from = result)  # Dynamic orientation
      }

      title_text <- if (input$Treatment == "Pooled") {
        paste("Summary:", input$SummaryType)
      } else {
        paste("Subject ID:", input$selectedID)
      }

      gt_table <- gt(summary_data) %>%
        tab_header(title = title_text) %>%
        fmt_number(columns = everything(), decimals = 2) %>%
        cols_align(align = "center", columns = everything()) %>%
        tab_style(
          style = list(
            cell_fill(color = "lightgreen"),
            cell_text(weight = "bold", color = "black")
          ),
          locations = cells_column_labels(everything())
        ) %>%
        tab_options(table.width = pct(100))

      gt_output <- gt_table %>%
        as_raw_html()

      HTML(gt_output)
    })
  
    # Summary statistics for Imputed Data
    output$Summary_imputed <- renderUI({
      summary_data <- if (input$Treatment == "Pooled") {
        data()$imputed %>%
          group_by(visit, time) %>%
          summarise(result = round(match.fun(input$SummaryType)(result, na.rm = TRUE), 3)) %>%
          pivot_wider(names_from = visit, values_from = result)
      } else {
        data()$imputed %>%
          filter(subject == input$selectedID) %>%
          group_by(visit, time) %>%
          summarise(result = round(result, 3)) %>%
          pivot_wider(names_from = visit, values_from = result)  # Dynamic orientation
      }

      title_text <- if (input$Treatment == "Pooled") {
        paste("Summary:", input$SummaryType)
      } else {
        paste("Subject ID:", input$selectedID)
      }

      gt_table <- gt(summary_data) %>%
        tab_header(title = title_text) %>%
        fmt_number(columns = everything(), decimals = 2) %>%
        cols_align(align = "center", columns = everything()) %>%
        tab_style(
          style = list(
            cell_fill(color = "lightgreen"),
            cell_text(weight = "bold", color = "black")
          ),
          locations = cells_column_labels(everything())
        ) %>%
        tab_options(table.width = pct(100))

      gt_output <- gt_table %>%
        as_raw_html()

      HTML(gt_output)
    })
  })
}
# Run the application
shinyApp(ui = ui, server = server)

```

# Step 3: Generate AUC

## AUC calculation


```{r}
ui <- fluidPage(
  useShinyjs(),  # Enable shinyjs for showing/hiding UI elements

   tags$head(
    tags$link(rel = "stylesheet", type = "text/css", href = "styles.css")
  ),

  # Main UI Elements
  fluidRow(
    column(4,
           div(class = "well",
               h3("Options"),
               radioButtons("Measurement", "Measurement:", choices = c("Glucose", "C-peptide"), selected = "C-peptide", inline = TRUE),
               radioButtons("Treatment", "Visualization:", choices = c("Pooled", "Individual"), selected = "Pooled", inline = TRUE)
           )
    ),
    column(4,
           div(class = "well",
               h3("Additional Settings"),
               conditionalPanel(
                 condition = "input.Treatment == 'Pooled'",
                 checkboxInput("AUC_Summary", "Summary", value = FALSE)
               ),
               conditionalPanel(
                 condition = "input.Treatment == 'Pooled'",
                 checkboxInput("CI", "Confidence Interval", value = FALSE)
               )
           )
    ),
    column(4,
           div(class = "well",
               h3("Summary Options"),
               conditionalPanel(
                 condition = "input.AUC_Summary == true ",
                 selectInput("AUC_SummaryType", "Summary:", choices = c("mean", "sd", "median", "min", "max", "IQR"), selected = "mean")
               ),
               conditionalPanel(
                 condition = "input.CI == true",
                 sliderInput("CI_level", "Confidence Level", min = 0.8, max = 1, value = 0.95, step = 0.025)
               ),
               conditionalPanel(
                 condition = "input.Treatment == 'Individual'",
                 uiOutput("individualSelect")
               )
           )
    )
  ),

  # Run Button
  fluidRow(
    column(12,
           div(class = "well",
               actionButton("runBtn", "Run", class = "btn-primary", style = "display: block; margin: 0 auto;")
           )
    )
  ),

  # Plots and Tables
  fluidRow(
    column(6,
           div(class = "well",
               h3("Raw Data"),
               plotlyOutput("AUCPlot_raw", height = "400px"),
               uiOutput("AUC_raw")
           )
    ),
    column(6,
           div(class = "well",
               h3("Imputed Data"),
               plotlyOutput("AUCPlot_imputed", height = "400px"),
               uiOutput("AUC_imputed")
           )
    )
  )
)

server <- function(input, output, session) {
  imputed_data <- reactive({
    list(cpep = data_cpep_imputed, gluc = data_gluc_imputed)
  })
  

  data <- reactive({
    if (input$Measurement == "Glucose") {
      list(raw = data_gluc, imputed = imputed_data()$gluc)
    } else {
      list(raw = data_cpep, imputed = imputed_data()$cpep)
    }
  })
    # Hide Summary checkbox if Individual is selected
  observe({
    if (input$Treatment == "Individual") {
      shinyjs::hide("AUC_Summary")
      shinyjs::hide("CI")
      shinyjs::hide("AUC_SummaryType")
      shinyjs::hide("CI_level")
      shinyjs::show("individualSelect")
    } else {
      shinyjs::show("AUC_Summary")
      shinyjs::show("CI")
      shinyjs::show("AUC_SummaryType")
      shinyjs::show("CI_level") 
      shinyjs::hide("individualSelect")
    }
  })
  # UI for selecting individual IDs
  output$individualSelect <- renderUI({
    selectInput("selectedID", "Select ID:",
                choices = unique(data()$raw$subject),
                selected = unique(data()$raw$subject)[1])
  })
  observeEvent(input$runBtn, {
    # Show AUC results after "Run" button is clicked
    show("AUC_raw")
    show("AUC_imputed")
    show("AUCPlot_raw")
    show("AUCPlot_imputed")

     # AUC Plot for raw data (Left Column) using plotly with conditional CI
  output$AUCPlot_raw <- renderPlotly({
    req(input$runBtn)
    data <- data()$raw
    data$time <- sapply(data$time, convert_to_minutes)

    auc_trapezoidal <- data %>%
      group_by(subject, visit) %>%
      summarise(auc = trapezoidal_auc(as.numeric(time), result)) %>%
      ungroup()
    auc_trapezoidal$visit <- factor(auc_trapezoidal$visit, levels = c("0", "2", "4", "8", "12", "16", "20", "26"))

    if (input$Treatment == "Pooled") {
      summary_data <- auc_trapezoidal %>%
        group_by(visit) %>%
        summarise(
          auc_mean = match.fun(input$AUC_SummaryType)(auc, na.rm = TRUE),
          auc_sd = sd(auc, na.rm = TRUE),
          auc_lower = auc_mean - qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * auc_sd / sqrt(n()),
          auc_upper = auc_mean + qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * auc_sd / sqrt(n())
        )
      plot <- plot_ly(summary_data, x = ~visit, y = ~auc_mean, name = 'AUC Mean', type = 'scatter', mode = 'lines+markers') %>%
        layout(xaxis = list(title = "Visit"),
               yaxis = list(title = "AUC"),
               showlegend = FALSE,
               title = paste("AUC Summary:", input$AUC_SummaryType)
        )

      if (input$CI) {
        plot <- plot %>%
          add_ribbons(ymin = ~auc_lower, ymax = ~auc_upper, name = 'CI',
                      line = list(color = 'rgba(7, 164, 181, 0.05)'),
                      fillcolor = 'rgba(7, 164, 181, 0.2)')
      }

    } else if (input$Treatment == "Individual") {
      auc_ID <- auc_trapezoidal %>% filter(subject == input$selectedID)
      plot <- plot_ly(auc_ID, x = ~visit, y = ~auc, type = 'scatter', mode = 'lines+markers',
                      name = 'AUC') %>%
        layout(xaxis = list(title = "Visit"),
               yaxis = list(title = "AUC"),
               showlegend = FALSE,
               title = paste("AUC of Subject ID:", input$selectedID)
        )
    }
    plot
  })
  
  # AUC summary table for raw data
  output$AUC_raw <- renderUI({
    auc_trapezoidal <- data()$raw %>%
      group_by(subject, visit) %>%
      summarise(auc = trapezoidal_auc(as.numeric(time), result)) %>%
      ungroup()
    auc_trapezoidal$visit <- factor(auc_trapezoidal$visit, levels = c("0", "2", "4", "8", "12", "16", "20", "26"))

    if (input$Treatment == "Pooled") {
      summary_data <- auc_trapezoidal %>%
        group_by(visit) %>%
        summarise(
          auc_mean = match.fun(input$AUC_SummaryType)(auc, na.rm = TRUE),
          auc_sd = sd(auc, na.rm = TRUE),
          auc_lower = auc_mean - qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * auc_sd / sqrt(n()),
          auc_upper = auc_mean + qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * auc_sd / sqrt(n())
        )
      summary_data$visit <- factor(summary_data$visit, levels = c("0", "2", "4", "8", "12", "16", "20", "26"))
      gt_table <- gt(summary_data) %>%
        tab_header(title = paste("AUC Summary:", input$AUC_SummaryType)) %>%
        fmt_number(columns = everything(), decimals = 2) %>%
        cols_align(align = "center", columns = everything()) %>%
        tab_style(
          style = list(
            cell_fill(color = "lightgreen"),
            cell_text(weight = "bold", color = "black")
          ),
          locations = cells_column_labels(everything())
        ) %>%
        tab_options(table.width = pct(100))

    } else if (input$Treatment == "Individual") {
      auc_ID <- auc_trapezoidal %>% filter(subject == input$selectedID)
      gt_table <- gt(auc_ID) %>%
        tab_header(title = paste("AUC of Subject ID:", input$selectedID)) %>%
        fmt_number(columns = everything(), decimals = 2) %>%
        cols_align(align = "center", columns = everything()) %>%
        tab_style(
          style = list(
            cell_fill(color = "lightgreen"),
            cell_text(weight = "bold", color = "black")
          ),
          locations = cells_column_labels(everything())
        ) %>%
        tab_options(table.width = pct(100))
    } else {
      NULL
    }
      gt_output <- gt_table %>%
        as_raw_html()

      HTML(gt_output)
    
    
  })
  
  # AUC plot for Imputed data (Right Column) using plotly with conditional CI
  output$AUCPlot_imputed <- renderPlotly({
    req(input$runBtn)
    data <- data()$imputed
    data$time <- sapply(data$time, convert_to_minutes)

    auc_trapezoidal <- data %>%
      filter(!is.na(result)) %>%   # Ensure NA values are excluded
      group_by(subject, visit) %>%
      summarise(auc = trapezoidal_auc(as.numeric(time), result)) %>%
      ungroup()
    auc_trapezoidal$visit <- factor(auc_trapezoidal$visit, levels = c("0", "2", "4", "8", "12", "16", "20", "26"))
    if (input$Treatment == "Pooled") {
      summary_data <- auc_trapezoidal %>%
        group_by(visit) %>%
        summarise(
          auc_mean = match.fun(input$AUC_SummaryType)(auc, na.rm = TRUE),
          auc_sd = sd(auc, na.rm = TRUE),
          auc_lower = auc_mean - qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * auc_sd / sqrt(n()),
          auc_upper = auc_mean + qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * auc_sd / sqrt(n())
        )
      summary_data$visit <- factor(summary_data$visit, levels = c("0", "2", "4", "8", "12", "16", "20", "26"))
      plot <- plot_ly(summary_data, x = ~visit, y = ~auc_mean, name = 'AUC Mean', type = 'scatter', mode = 'lines+markers') %>%
        layout(xaxis = list(title = "Visit"),
               yaxis = list(title = "AUC"),
               showlegend = FALSE,
               title = paste("AUC Summary:", input$AUC_SummaryType)
        )

      if (input$CI) {
        plot <- plot %>%
          add_ribbons(ymin = ~auc_lower, ymax = ~auc_upper, name = 'CI',
                      line = list(color = 'rgba(7, 164, 181, 0.05)'),
                      fillcolor = 'rgba(7, 164, 181, 0.2)')
      }

    } else if (input$Treatment == "Individual") {
      auc_ID <- auc_trapezoidal %>% filter(subject == input$selectedID)
      plot <- plot_ly(auc_ID, x = ~visit, y = ~auc, type = 'scatter', mode = 'lines+markers',
                      name = 'AUC') %>%
        layout(xaxis = list(title = "Visit"),
               yaxis = list(title = "AUC"),
               showlegend = FALSE,
               title = paste("AUC of Subject ID:", input$selectedID)
        )
    }
    plot
  })
  
  # AUC summary table for imputed data
  output$AUC_imputed <- renderUI({
    auc_trapezoidal <- data()$imputed %>%
      filter(!is.na(result)) %>%   # Ensure NA values are excluded
      group_by(subject, visit) %>%
      summarise(auc = trapezoidal_auc(as.numeric(time), result)) %>%
      ungroup()
    auc_trapezoidal$visit <- factor(auc_trapezoidal$visit, levels = c("0", "2", "4", "8", "12", "16", "20", "26"))

    if (input$Treatment == "Pooled") {
      summary_data <- auc_trapezoidal %>%
        group_by(visit) %>%
        summarise(
          auc_mean = match.fun(input$AUC_SummaryType)(auc, na.rm = TRUE),
          auc_sd = sd(auc, na.rm = TRUE),
          auc_lower = auc_mean - qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * auc_sd / sqrt(n()),
          auc_upper = auc_mean + qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * auc_sd / sqrt(n())
        )
      summary_data$visit <- factor(summary_data$visit, levels = c("0", "2", "4", "8", "12", "16", "20", "26"))
      gt_table <- gt(summary_data) %>%
        tab_header(title = paste("AUC Summary:", input$AUC_SummaryType)) %>%
        fmt_number(columns = everything(), decimals = 2) %>%
        cols_align(align = "center", columns = everything()) %>%
        tab_style(
          style = list(
            cell_fill(color = "lightgreen"),
            cell_text(weight = "bold", color = "black")
          ),
          locations = cells_column_labels(everything())
        ) %>%
        tab_options(table.width = pct(100))
    } else if (input$Treatment == "Individual") {
      auc_ID <- auc_trapezoidal %>% filter(subject == input$selectedID)
      gt_table <- gt(auc_ID) %>%
        tab_header(title = paste("AUC of Subject ID:", input$selectedID)) %>%
        fmt_number(columns = everything(), decimals = 2) %>%
        cols_align(align = "center", columns = everything()) %>%
        tab_style(
          style = list(
            cell_fill(color = "lightgreen"),
            cell_text(weight = "bold", color = "black")
          ),
          locations = cells_column_labels(everything())
        ) %>%
        tab_options(table.width = pct(100))
    } else {
      NULL
    }
       gt_output <- gt_table %>%
        as_raw_html()

      HTML(gt_output)
  })
  })
}
 shinyApp(ui = ui, server = server)

```


# Step 4: Generate Index Calculation
```{r}

ui <- fluidPage(
  useShinyjs(),  # Enable shinyjs for showing/hiding UI elements

  tags$head(
    tags$link(rel = "stylesheet", type = "text/css", href = "styles.css")
  ),

  # Main UI Elements
  fluidRow(
    column(6,
           div(class = "well",
               h3("Visualization Summary & CI"),
               radioButtons("Treatment", "Visualization:", choices = c("Pooled", "Individual"), selected = "Pooled", inline = TRUE),
               conditionalPanel(condition = "input.Treatment == 'Pooled'",
                 checkboxInput("Summary", "Summary", value = FALSE),
                 checkboxInput("CI", "Confidence Interval", value = FALSE)
               ),
               conditionalPanel(
                 condition = "input.Treatment == 'Individual'",
                 uiOutput("individualSelect")
               )
           )
    ),
    column(6,
           div(class = "well",
               h3("Other Options"),
               conditionalPanel(
                 condition = "input.Summary == true & input.Treatment == 'Pooled'",
                 selectInput("SummaryType", "Summary Type:", choices = c("mean", "sd", "median", "min", "max", "IQR"), selected = "mean")
               ),
               conditionalPanel(
                 condition = "input.CI == true & input.Treatment == 'Pooled'",
                 sliderInput("CI_level", "Confidence Level:", min = 0.8, max = 1, value = 0.95, step = 0.025)
               )
           )
    )
  ),

  # Run Button
  fluidRow(
    column(12,
           div(class = "well",
               actionButton("runBtn", "Run", class = "btn-primary", style = "display: block; margin: 0 auto;")
           )
    )
  ),

  # Plots and Tables (Main Panel - Left as it is)
  fluidRow(
    column(6,
           div(class = "well",
               h3("Raw Data"),
               plotlyOutput("IndexPlot_raw", height = "400px"),
               uiOutput("IndexSummary_raw")
           )
    ),
    column(6,
           div(class = "well",
               h3("Imputed Data"),
               plotlyOutput("IndexPlot_imputed", height = "400px"),
               uiOutput("IndexSummary_imputed")
           )
    )
  )
)

server <- function(input, output, session){
  imputed_data <- reactive({
    list(cpep = data_cpep_imputed, gluc = data_gluc_imputed)
  })
   
  imputed_data <- reactive({
    list(cpep = data_cpep_imputed, gluc = data_gluc_imputed)
  })
  data <- reactive({
    list(raw = list(cpep = data_cpep, gluc = data_gluc),
         imputed = list(cpep = imputed_data()$cpep, gluc = imputed_data()$gluc))
  })
  
  observe({
    if (input$Treatment == "Individual") {
      shinyjs::hide("Summary")
      shinyjs::hide("CI")
      shinyjs::hide("SummaryType")
      shinyjs::hide("CI_level")
      shinyjs::show("individualSelect")
    } else {
      shinyjs::show("Summary")
      shinyjs::show("CI")
      shinyjs::show("SummaryType")
      shinyjs::show("CI_level") 
      shinyjs::hide("individualSelect")
    }
  })
  
  output$individualSelect <- renderUI({
    selectInput("selectedID", "Select ID:",
                choices = unique(data()$raw$cpep$subject),
                selected = unique(data()$raw$cpep$subject)[1])
  })
  
  observeEvent(input$runBtn, {
    shinyjs::show("IndexPlot_raw")
    shinyjs::show("IndexPlot_imputed")
    shinyjs::show("IndexSummary_raw")
    shinyjs::show("IndexSummary_imputed")
    
    # Interaction Plot for Raw Data Index using plotly
    output$IndexPlot_raw <- renderPlotly({
      req(input$runBtn)
      
      plot_data <- calculate_index(data()$raw$cpep, data()$raw$gluc)
      
      if (input$Treatment == "Pooled") {
        summary_data <- plot_data %>%
          group_by(visit) %>%
          summarise(
            index_mean = round(match.fun(input$SummaryType)(index, na.rm = TRUE), 3),
            index_sd = sd(index, na.rm = TRUE),
            index_lower = index_mean - qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * index_sd / sqrt(n()),
            index_upper = index_mean + qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * index_sd / sqrt(n())
          ) %>%
          ungroup()
        
        plot <- plot_ly(summary_data, x = ~visit, y = ~index_mean, type = 'scatter', mode = 'lines+markers') %>%
          layout(
            xaxis = list(title = "Visit"),
            yaxis = list(title = "Index"),
            title = paste("Index Summary:", input$SummaryType)
          )
        if (input$CI) {
          plot <- plot %>%
            add_ribbons(
              ymin = ~index_lower, ymax = ~index_upper,
              line = list(color = 'transparent'),
              fillcolor = ~paste0("rgba(", col2rgb("red")[1], ",", col2rgb("red")[2], ",", col2rgb("red")[3], ",0.2)"),
              hoverinfo = "none",
              showlegend = FALSE
            )
        }
      } else if (input$Treatment == "Individual") {
        plot_data <- plot_data %>% filter(subject == input$selectedID)
        
        plot <- plot_ly(plot_data %>% filter(!is.na(index)), x = ~visit, y = ~index, type = 'scatter', mode = 'lines+markers') %>%
          layout(
            xaxis = list(title = "Visit"),
            yaxis = list(title = "Index"),
            title = paste("Subject ID:", input$selectedID)
          )
      }
      plot
    })
    
    # Interaction Plot for Imputed Data Index using plotly
    output$IndexPlot_imputed <- renderPlotly({
      req(input$runBtn)
      
      plot_data <- calculate_index(data()$imputed$cpep, data()$imputed$gluc)
      
      if (input$Treatment == "Pooled") {
        summary_data <- plot_data %>%
          group_by(visit) %>%
          summarise(
            index_mean = round(match.fun(input$SummaryType)(index, na.rm = TRUE), 3),
            index_sd = sd(index, na.rm = TRUE),
            index_lower = index_mean - qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * index_sd / sqrt(n()),
            index_upper = index_mean + qt(1 - (1 - input$CI_level) / 2, df = n() - 1) * index_sd / sqrt(n())
          ) %>%
          ungroup()
        
        plot <- plot_ly(summary_data, x = ~visit, y = ~index_mean, type = 'scatter', mode = 'lines+markers') %>%
          layout(
            xaxis = list(title = "Visit"),
            yaxis = list(title = "Index"),
            title = paste("Index Summary :", input$SummaryType)
          )
        
        if (input$CI) {
          plot <- plot %>%
            add_ribbons(
              ymin = ~index_lower, ymax = ~index_upper,
              line = list(color = 'transparent'),
              fillcolor = ~paste0("rgba(", col2rgb("red")[1], ",", col2rgb("red")[2], ",", col2rgb("red")[3], ",0.2)"),
              hoverinfo = "none",
              showlegend = FALSE
            )
        }
      } else if (input$Treatment == "Individual") {
        plot_data <- plot_data %>% filter(subject == input$selectedID)
        plot <- plot_ly(plot_data %>% filter(!is.na(index)), x = ~visit, y = ~index, type = 'scatter', mode = 'lines+markers') %>%
          layout(
            xaxis = list(title = "Visit"),
            yaxis = list(title = "Index"),
            title = paste("Subject ID:", input$selectedID)
          )
      }
      
      plot
    })
    
    # Summary for Raw Data Index using gt
    output$IndexSummary_raw <- renderUI({
      req(input$runBtn)
      
      index_data <- calculate_index(data()$raw$cpep, data()$raw$gluc)
      
      summary_data <- if (input$Treatment == "Pooled") {
        index_data %>%
          group_by(visit) %>%
          summarise(index_summary = round(match.fun(input$SummaryType)(index, na.rm = TRUE), 3)) %>%
          pivot_wider(names_from = visit, values_from = index_summary)
      } else {
        index_data %>%
          filter(subject == input$selectedID) %>%
          group_by(visit) %>%
          summarise(index_summary = round(index, 3)) %>%
          pivot_wider(names_from = visit, values_from = index_summary)
      }
      
      title_text <- if (input$Treatment == "Pooled") {
        paste("Index Summary:", input$SummaryType)
      } else {
        paste("Subject ID:", input$selectedID)
      }
      
      gt_table <- gt(summary_data) %>%
        tab_header(title = title_text) %>%
        fmt_number(columns = everything(), decimals = 2) %>%
        cols_align(align = "center", columns = everything()) %>%
        tab_style(
          style = list(
            cell_fill(color = "lightgreen"),
            cell_text(weight = "bold", color = "black")
          ),
          locations = cells_column_labels(everything())
        ) %>%
        tab_options(table.width = pct(100))
      
      gt_output <- gt_table %>%
        as_raw_html()
      
      HTML(gt_output)
    })
    
    # Summary for Imputed Data Index using gt
    output$IndexSummary_imputed <- renderUI({
      req(input$runBtn)
      
      index_data <- calculate_index(data()$imputed$cpep, data()$imputed$gluc)
      
      summary_data <- if (input$Treatment == "Pooled") {
        index_data %>%
          group_by(visit) %>%
          summarise(index_summary = round(match.fun(input$SummaryType)(index, na.rm = TRUE), 3)) %>%
          pivot_wider(names_from = visit, values_from = index_summary)
      } else {
        index_data %>%
          filter(subject == input$selectedID) %>%
          group_by(visit) %>%
          summarise(index_summary = round(index, 3)) %>%
          pivot_wider(names_from = visit, values_from = index_summary)
      }
      
      title_text <- if (input$Treatment == "Pooled") {
        paste("Index Summary :", input$SummaryType)
      } else {
        paste("Subject ID:", input$selectedID)
      }
      
      gt_table <- gt(summary_data) %>%
        tab_header(title = title_text) %>%
        fmt_number(columns = everything(), decimals = 2) %>%
        cols_align(align = "center", columns = everything()) %>%
        tab_style(
          style = list(
            cell_fill(color = "lightgreen"),
            cell_text(weight = "bold", color = "black")
          ),
          locations = cells_column_labels(everything())
        ) %>%
        tab_options(table.width = pct(100))
      
      gt_output <- gt_table %>%
        as_raw_html()
      
      HTML(gt_output)
    })
  })
}

shinyApp(ui = ui, server = server)


```
 

